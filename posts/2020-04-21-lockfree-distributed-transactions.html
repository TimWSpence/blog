<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>My Hakyll Blog - Lock-free Distributed Transactions</title>
        <link rel="stylesheet" href="../stylesheet.css" />
    </head>
    <body>
        <header>
            <nav>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>Lock-free Distributed Transactions</h1>
            <article>
    <section class="header">
        Posted on April 21, 2020
        
    </section>
    <section>
        <p>This is a description of a simple but (as far as I am aware) novel solution a devised some time ago for implementing lock-free distributed transactions. I thought it was quite elegant so I’ve summarised it here for your interest.</p>
<h3 id="the-problem">The problem</h3>
<p>In order to function, the API we were writing needed to obtain metadata on our customer’s configuration. This was stored in a Postgres database which for Google Cloud reasons was quite limited in terms of the number of concurrent connections it could support, and served via another internal API. Because of the concurrent connections limit, we were struggling to scale our metadata API to support the volume of requests inbound from our main API.</p>
<p>We therefore decided that we would like to replicate the metadata to a more scalable data store that would enable us to scale the API (we’ll call it the metadata service from now on) sitting in front of it. To that end, we wanted to design a system with the follow characteristics: - Metadata should be stored in a scalable data store (we were already using Google BigTable so this was the natural choice) - Metadata should be synchronized between Postgres and the scalabale data store (presumably by some scheduled sync job) - It is ok for the sync to be eventually consistent (we’re happy with a short delay when our API runs with old data) - It is not ok for a sync to only partially succeed as a partially successful write could lead to inconsistent behaviour from the API consuming it - The metadata service will be auto-scaled and load-balanced via Kubernetes so the sync job cannot depend on talking to a particular instance of the service</p>
<p>These last two requirements in particular cause some problems - we cannot maintain any transaction-related state in the metadata service as the next request from the sync job may be load-balanced to a different instance.</p>
<h3 id="the-solution">The solution</h3>
<p>This is probably by no means the only solution to the problem but it is the one I came up with so here goes.</p>
<p>The idea is similar to atomic renaming of directories and assumes that the backing store is a key-value store (such as Google BigTable). The metadata service will expose an API that looks like this (assuming that the imaginatively named <code>X</code>, <code>Y</code> and <code>Z</code> are the domain objects that we are syncing):</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">newtype</span> <span class="dt">Version</span> <span class="fu">=</span> <span class="dt">Version</span> {<span class="ot"> getVersion ::</span> <span class="dt">Int</span> }</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">newtype</span> <span class="dt">Id</span> <span class="fu">=</span> <span class="dt">Id</span> {<span class="ot"> getId ::</span> <span class="dt">UUID</span> }</a>
<a class="sourceLine" id="cb1-3" title="3"></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="ot">getX ::</span> <span class="dt">Version</span> <span class="ot">-&gt;</span> <span class="dt">Id</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">X</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="ot">setX ::</span> <span class="dt">Version</span> <span class="ot">-&gt;</span> <span class="dt">Id</span> <span class="ot">-&gt;</span> <span class="dt">X</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-6" title="6"></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="ot">getY ::</span> <span class="dt">Version</span> <span class="ot">-&gt;</span> <span class="dt">Id</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Y</span></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="ot">setY ::</span> <span class="dt">Version</span> <span class="ot">-&gt;</span> <span class="dt">Id</span> <span class="ot">-&gt;</span> <span class="dt">Y</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-9" title="9"></a>
<a class="sourceLine" id="cb1-10" title="10"><span class="ot">getZ ::</span> <span class="dt">Version</span> <span class="ot">-&gt;</span> <span class="dt">Id</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Z</span></a>
<a class="sourceLine" id="cb1-11" title="11"><span class="ot">setZ ::</span> <span class="dt">Version</span> <span class="ot">-&gt;</span> <span class="dt">Id</span> <span class="ot">-&gt;</span> <span class="dt">Z</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-12" title="12"></a>
<a class="sourceLine" id="cb1-13" title="13"><span class="ot">getCurrentVersion ::</span> <span class="dt">IO</span> <span class="dt">Version</span></a>
<a class="sourceLine" id="cb1-14" title="14"><span class="ot">setCurrentVersion ::</span> <span class="dt">Version</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a></code></pre></div>
<p>The API should not cache data (or at least this requires more thought and should operate as a write-through cache). The metadata service responds to <code>get</code> requests by reading the current version and generating a key obtained by concatenating the version and the id and retrieving that row from the data store:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="ot">getX ::</span> <span class="dt">Id</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">X</span></a>
<a class="sourceLine" id="cb2-2" title="2">getX <span class="fu">id</span> <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-3" title="3">  version <span class="ot">&lt;-</span> getCurrentVersion</a>
<a class="sourceLine" id="cb2-4" title="4">  <span class="kw">let</span> key <span class="fu">=</span> version <span class="fu">&lt;&gt;</span> <span class="fu">id</span></a>
<a class="sourceLine" id="cb2-5" title="5">  readFromStore key</a>
<a class="sourceLine" id="cb2-6" title="6"></a>
<a class="sourceLine" id="cb2-7" title="7"><span class="ot">writeX ::</span> <span class="dt">Version</span> <span class="ot">-&gt;</span> <span class="dt">Id</span> <span class="ot">-&gt;</span> <span class="dt">X</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-8" title="8">writeX v <span class="fu">id</span> x <span class="fu">=</span> writeToDataStore key x</a>
<a class="sourceLine" id="cb2-9" title="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-10" title="10">    key <span class="fu">=</span> v <span class="fu">&lt;&gt;</span> <span class="fu">id</span></a></code></pre></div>
<p>The client can transactionally write a new version of the metadata by generating a new version, writing all the data against that and then setting the current version to the generated version. Note that the transaction may succeed but the client be unaware if sending the response to the <code>setCurrentVersion</code> fails. Note also that this requires the version generated by the client to be unique. In our case we only have one client so using the current time in millis as the version is guaranteed to be unique (indeed strictly monotonic). If you have multiple clients, then you could concatenate eg a client-specific UUID and the timestamp to generate a unique version and then it is a case of last write wins - whichever client writes to the current version field second will have their writes visible.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="ot">sync ::</span> [(<span class="dt">Id</span>, <span class="dt">X</span>)] <span class="ot">-&gt;</span> [(<span class="dt">Id</span>, <span class="dt">Y</span>)] <span class="ot">-&gt;</span> [(<span class="dt">Id</span>, <span class="dt">Z</span>)] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb3-2" title="2">sync xs ys zs <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-3" title="3">  version <span class="ot">&lt;-</span> <span class="dt">Version</span> <span class="fu">&lt;$&gt;</span> getCurrentTimeMills</a>
<a class="sourceLine" id="cb3-4" title="4">  <span class="fu">traverse</span> (<span class="fu">uncurry</span> <span class="fu">$</span> setX version) xs</a>
<a class="sourceLine" id="cb3-5" title="5">  <span class="fu">traverse</span> (<span class="fu">uncurry</span> <span class="fu">$</span> setY version) ys</a>
<a class="sourceLine" id="cb3-6" title="6">  <span class="fu">traverse</span> (<span class="fu">uncurry</span> <span class="fu">$</span> setZ version) zs</a>
<a class="sourceLine" id="cb3-7" title="7">  setCurrentVersion version</a></code></pre></div>
<p>And there you have it! We can sync data from our relational database to a key-value store and guarantee that updates will only be visible if the entire transaction succeeds. This probably requires some form of garbage collection on the key-value store to remove old versions. For Google BigTable, we get that for free as you can set a TTL on rows (or cells to be more precise - BigTable has a slightly more complex data model). We set our TTL high enough (~ 1 week) that with running a sync job every 5 minutes we’re pretty confident we can recover from any failures in the sync job.</p>
<h3 id="extensions">Extensions</h3>
<p>Obviously this approach trivially generalizes to transactionally updating subsets of the data, so long as there is a deterministic function <code>Data -&gt; Version Row</code>, which tells us where to read the current version for that peice of data. Not sure how useful that is but it is worth noting anyway.</p>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
