<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>My Hakyll Blog - Optimized Docker builds for Haskell stack</title>
        <link rel="stylesheet" href="../stylesheet.css" />
    </head>
    <body>
        <header>
            <nav>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>Optimized Docker builds for Haskell stack</h1>
            <article>
    <section class="header">
        Posted on August  2, 2019
        
    </section>
    <section>
        <p>Stack recently <a href="https://github.com/commercialhaskell/stack/releases/tag/v2.1.1">removed support for automatically building Docker images for Haskell apps</a>, citing the reason that ‚Äúwith the advent of Docker multistage builds, this functionality is no longer useful.‚Äù</p>
<p>However, I‚Äôve yet to find a good resource on how to actually write a multistage Docker build for a Stack-based Haskell application. I <a href="https://www.reddit.com/r/haskell/comments/cdiyd6/multistage_docker_builds_replacing_stack_image/">posted an initial solution on r/Haskell</a> but was rightly challenged that this solution requires we re-compile all dependencies on every build, which is expensive in a CI environment.</p>
<p>So I went back to the drawing board to come up with a Docker build for Haskell applications which would use multistage builds to optimize both final image size and build time.</p>
<pre class="docker"><code># Loosely based on https://www.fpcomplete.com/blog/2017/12/building-haskell-apps-with-docker
FROM fpco/stack-build:lts-13.27 as dependencies
RUN mkdir /opt/build
WORKDIR /opt/build

# GHC dynamically links its compilation targets to lib gmp
RUN apt-get update \
  &amp;&amp; apt-get download libgmp10
RUN mv libgmp*.deb libgmp.deb

# Docker build should not use cached layer if any of these is modified
COPY stack.yaml package.yaml stack.yaml.lock /opt/build/
RUN stack build --system-ghc --dependencies-only

# -------------------------------------------------------------------------------------------
FROM fpco/stack-build:lts-13.27 as build

# Copy compiled dependencies from previous stage
COPY --from=dependencies /root/.stack /root/.stack
COPY . /opt/build/

WORKDIR /opt/build

RUN stack build --system-ghc

RUN mv &quot;$(stack path --local-install-root --system-ghc)/bin&quot; /opt/build/bin

# -------------------------------------------------------------------------------------------
# Base image for stack build so compiled artifact from previous
# stage should run
FROM ubuntu:16.04 as app
RUN mkdir -p /opt/app
WORKDIR /opt/app

# Install lib gmp
COPY --from=dependencies /opt/build/libgmp.deb /tmp
RUN dpkg -i /tmp/libgmp.deb &amp;&amp; rm /tmp/libgmp.deb

COPY --from=build /opt/build/bin .
EXPOSE 8080
CMD [&quot;/opt/app/app&quot;, &quot;8080&quot;]</code></pre>
<div class="sourceCode" id="cb2"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" title="1"><span class="ex">docker</span> pull ns/app-dependencies:latest <span class="kw">||</span> <span class="fu">true</span></a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="ex">docker</span> build --target dependencies --cache-from ns/app-dependencies:latest -t ns/app-dependencies .</a>
<a class="sourceLine" id="cb2-4" title="4"></a>
<a class="sourceLine" id="cb2-5" title="5"><span class="ex">docker</span> build --target app --cache-from ns/app-dependencies:latest -t ns/app .</a>
<a class="sourceLine" id="cb2-6" title="6"></a>
<a class="sourceLine" id="cb2-7" title="7"><span class="ex">docker</span> push ns/app-dependencies:latest</a>
<a class="sourceLine" id="cb2-8" title="8"><span class="ex">docker</span> push ns/app:latest</a></code></pre></div>
<p>We‚Äôve defined 3 Docker images here:</p>
<ul>
<li>The first is responsible for fetching LibGMP (which GHC dynamically links its compilation targets to) and compiling dependencies. It should only need to be re-built if <code>stack.yaml</code> or <code>package.yaml</code> are modified. Fortunately, that is exactly the behaviour that Docker‚Äôs layer caching gives us.</li>
<li>The second is where we build our application and it re-uses Stack‚Äôs cache of compiled dependencies from the first stage.</li>
<li>Finally, the third image will be our compiled application. Note, that it‚Äôs based on Ubuntu rather than <code>fpco/stack-build</code> and hence is much more lightweight. For one of our applications, the dependencies image was 10.3GB whereas the final app image was just 142MB!</li>
</ul>
<p>This all works because of the build script, which uses Docker‚Äôs ‚Äî-cache-from feature to re-use layers from the dependencies stage. If you find that CI builds are still too slow (you are downloading a ~10GB image after all), you may want to <code>docker save</code> your dependencies image to a persistent shared folder if the filesystem is faster than the network‚Äîalthough I couldn‚Äôt possibly condone such a hacky solution. üòú Also, watch out for concurrent builds if you do this: you might need to rely on atomic renames or similar.</p>
<p>In fact, downloading the images was so slow that we switched to using the official <code>haskell:8.6.5</code> as a base image instead of <code>fpco/stack-build</code>. However, this uses an older version of Stack and doesn‚Äôt seem to be updated as frequently so I wouldn‚Äôt necessarily recommend it unless the build times are too painful for you. If you do switch to this, remember to update the base image for your final stage to be the same as the base image for haskell (<code>debian:stretch</code> instead of <code>ubuntu:16.04</code>) as well to ensure your app is compiled against the correct version of glibc, etc</p>
<h3 id="caveat-emptor">Caveat Emptor</h3>
<p>Note that this solution exhibits degenerate behaviour in the case where a change has modified <code>{stack,package}.yaml</code> and there is at least one other change being built concurrently. In this case, the cache of compiled dependencies will be wiped out on every build as Docker sees that these files have been modified. The best solution I‚Äôve come up with if you need to modify the stack manifests is to make a small commit directly to master which only modifies these files. This should mean that that commit is a common ancestor of any work in progress and hence they all agree on the contents of <code>{stack,package}.yaml</code></p>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
