<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>My Hakyll Blog - Having your cake and eating it</title>
        <link rel="stylesheet" href="../stylesheet.css" />
    </head>
    <body>
        <header>
            <nav>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <h1>Having your cake and eating it</h1>
            <article>
    <section class="header">
        Posted on January 31, 2019
        
    </section>
    <section>
        <p>At Permutive, we’re committed to functional programming. That typically means also committing to immutable data structures (a very good thing!), but there are times when an algorithm would run much faster or be more space efficient if it could update state in-place.</p>
<p>Consider the very useful but much-maligned nub, which removes duplicates from a list:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="ot">nub ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb1-2" title="2">nub <span class="fu">=</span> nubBy (<span class="fu">==</span>)</a>
<a class="sourceLine" id="cb1-3" title="3"></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="ot">nubBy ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb1-5" title="5">nubBy eq [] <span class="fu">=</span>  []</a>
<a class="sourceLine" id="cb1-6" title="6">nubBy eq (x<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="fu">:</span> nubBy eq (<span class="fu">filter</span> (\ y <span class="ot">-&gt;</span> <span class="fu">not</span> (eq x y)) xs)</a></code></pre></div>
<p>This has O(n^2) time complexity due to an inner traversal of the list. But if we’re willing to introduce an Ord a restriction, we can reduce this to O(nlog(n)) by building up a binary tree, giving us the <a href="http://hackage.haskell.org/package/extra-1.6.14/docs/Data-List-Extra.html">nubOrd</a> function in Data.List.Extra. Further, we could replace the Ord a restriction with Hashable a and implement nub in O(n) average time if we could construct a mutable hashmap.</p>
<p>One way to achieve this mutable state would be to store our states inside an IORef, as this provides mutable memory protected by sequenced IO actions. It <em>would</em> run in constant space but <em>isn’t</em> completely satisfactory, since our types become polluted with IO. Clearly this shouldn’t be necessary: our nub function does not want to modify any non-local state.</p>
<p>This reveals something about the nature of the problem. The reason we’re required to introduce IO is because the compiler has no way to guarantee that we won’t share our mutable array with another thread, and hence to ensure referential transparency we must work within the IO monad.</p>
<p>So can we construct a type which permits in-place mutation but which cannot be shared between threads?</p>
<p>Yes! :)</p>
<p>(Many thanks to <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/1994/06/lazy-functional-state-threads.pdf">John Launchbury and Simon Peyton Jones — Lazy Functional State Threads</a>)</p>
<h2 id="the-st-monad">The ST Monad</h2>
<p>Haskell defines types ST s a and STRef s a that support—amongst others—the following operations:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="ot">newSTRef ::</span> a <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">STRef</span> s a)</a>
<a class="sourceLine" id="cb2-2" title="2"><span class="ot">readSTRef ::</span> <span class="dt">STRef</span> s a <span class="ot">-&gt;</span> <span class="dt">ST</span> s a</a>
<a class="sourceLine" id="cb2-3" title="3"><span class="ot">writeSTRef ::</span> <span class="dt">STRef</span> s a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</a>
<a class="sourceLine" id="cb2-4" title="4"><span class="ot">modifySTRef ::</span> <span class="dt">STRef</span> s a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</a></code></pre></div>
<p>Which means that we can write (pseudo-imperative) code, like:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="ot">increment ::</span> <span class="dt">STRef</span> s <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</a>
<a class="sourceLine" id="cb3-2" title="2">increment ref <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-3" title="3">  current <span class="ot">&lt;-</span> readSTRef ref</a>
<a class="sourceLine" id="cb3-4" title="4">  writeSTRef ref (current <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb3-5" title="5"><span class="ot">prog ::</span> <span class="dt">ST</span> s <span class="dt">Int</span></a>
<a class="sourceLine" id="cb3-6" title="6">prog <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-7" title="7">  ref <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span></a>
<a class="sourceLine" id="cb3-8" title="8">  increment ref</a>
<a class="sourceLine" id="cb3-9" title="9">  increment ref</a>
<a class="sourceLine" id="cb3-10" title="10">  readSTRef ref</a></code></pre></div>
<p>Thus far, this looks quite like IORef. The difference however is that we can safely extract a value from ST s a using:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="ot">{-# LANGUAGE RankNTypes #-}</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="ot">runST ::</span> (<span class="kw">forall</span> s<span class="fu">.</span> <span class="dt">ST</span> s a) <span class="ot">-&gt;</span> a</a></code></pre></div>
<p>For example:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1">runST<span class="ot"> prog ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-2" title="2">(runST prog) <span class="fu">==</span> <span class="dv">2</span> <span class="co">-- not haskell but you get the picture!</span></a></code></pre></div>
<p>This looks a lot like unsafePerformIO—in fact they are closely related internally but you need a <em>very</em> good reason to use unsafePerformIO. An STRef is backed by a piece of mutable memory. How does runST not violate referential transparency like unsafePerformIO does?</p>
<p>Let’s try to ‘leak’ the ref from an ST value to see what happens.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1">runST <span class="fu">$</span> newSTRef <span class="dv">0</span> <span class="co">-- attempt to leak the ref from a runST call</span></a>
<a class="sourceLine" id="cb6-2" title="2">                   <span class="co">-- does not compile!!</span></a></code></pre></div>
<p>The compiler will fail with the following error message:</p>
<pre><code>Couldn't match type ‘a’ with ‘STRef s Integer’ because type variable ‘s’ would escape its scope</code></pre>
<p>Why is this? Consider the types:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1">newSTRef <span class="dv">0</span><span class="ot"> ::</span> <span class="dt">ST</span> s (<span class="dt">STRef</span> s <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb8-2" title="2"><span class="ot">runST ::</span> (<span class="kw">forall</span> s<span class="fu">.</span> <span class="dt">ST</span> s a) <span class="ot">-&gt;</span> a</a></code></pre></div>
<p>Suppose we could apply runST to newSTRef 0. We might try:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1">runST <span class="fu">$</span> newSTRef <span class="dv">0</span><span class="ot"> ::</span> <span class="dt">STRef</span> s <span class="dt">Int</span></a></code></pre></div>
<p>But this contradicts the type of runST as the return type is dependent on s, whereas the return type of runST is independent of s</p>
<p>Similarly we can show that the compiler will not allow us to pass in an STRef to be evaluated by runST:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">let</span> v <span class="fu">=</span> runST (newVar <span class="dt">True</span>)</a>
<a class="sourceLine" id="cb10-2" title="2">  <span class="kw">in</span> runST (readVar v)</a></code></pre></div>
<p>If this were legal, v would have type ST s (STRef s Bool) and hence readVar v :: ST s Bool. Again, this does not match the type (forall s. ST s a) required by runST: s is free in the latter but not in the former.</p>
<p><strong>TL;DR </strong>The phantom type s means the compiler will prohibit us from passing an STRef as a parameter to runST or returning an STRef via runST. Hence we can guarantee that the mutable state is never shared and so runST is safe, unlike unsafePerformIO! (For a more rigorous proof see <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/1994/06/lazy-functional-state-threads.pdf">the original paper</a>)</p>
<h2 id="back-to-nub">Back to nub</h2>
<p>What has the ST monad bought us? We now have a way to perform in-place mutations while maintaining referential transparency! Here is nub running in O(n) on-average using a simplistic mutable hashmap as promised—specifically, using STArray which is built on top of ST and works much the same way.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="ot">nub ::</span> (<span class="dt">Hashable</span> a, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb11-2" title="2">nub l <span class="fu">=</span> runST <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb11-3" title="3">  arr <span class="ot">&lt;-</span> mr</a>
<a class="sourceLine" id="cb11-4" title="4">  forM_ l <span class="fu">$</span> \j <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb11-5" title="5">    <span class="kw">let</span> <span class="fu">index</span> <span class="fu">=</span> (hash j) <span class="ot">`mod`</span> <span class="dv">255</span></a>
<a class="sourceLine" id="cb11-6" title="6">    current <span class="ot">&lt;-</span> readArray arr <span class="fu">index</span></a>
<a class="sourceLine" id="cb11-7" title="7">    <span class="kw">let</span> new <span class="fu">=</span> <span class="kw">if</span> j <span class="ot">`elem`</span> current <span class="kw">then</span> current <span class="kw">else</span> j <span class="fu">:</span> current</a>
<a class="sourceLine" id="cb11-8" title="8">    writeArray arr <span class="fu">index</span> new</a>
<a class="sourceLine" id="cb11-9" title="9">  join <span class="fu">&lt;$&gt;</span> getElems arr</a>
<a class="sourceLine" id="cb11-10" title="10">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-11" title="11"><span class="ot">      mr ::</span> <span class="dt">ST</span> s (<span class="dt">STArray</span> s <span class="dt">Int</span> [a])</a>
<a class="sourceLine" id="cb11-12" title="12">      mr <span class="fu">=</span> newListArray (<span class="dv">0</span>, <span class="dv">255</span>) (<span class="fu">replicate</span> <span class="dv">256</span> [])</a></code></pre></div>
<p>Note that we have not had to sacrifice referential transparency to obtain this — the signature of the function is unchanged. It is also an almost direct translation from an equivalent C implementation, but guarantees that our mutable state cannot escape the scope of the nub function—something that no imperative language can do.</p>
<h2 id="tldr">TL;DR</h2>
<p>We can use the ST monad to implement functions that use mutable state for efficiency while maintaining referential transparency, and have the compiler guarantee that we won’t accidentally share that mutable state. :)</p>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
